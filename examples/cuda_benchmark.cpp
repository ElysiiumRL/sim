#include <iostream>\n#include <vector>\n#include <chrono>\n#include <random>\n#include <iomanip>\n\n#include \"../src/RocketSim.h\"\n\n#ifdef RS_CUDA_ENABLED\n#include \"../src/Sim/Arena/ArenaCuda.h\"\n#endif\n\nusing namespace RocketSim;\n\nstruct BenchmarkResults {\n    float avgStepTime;\n    float totalTime;\n    long long totalSteps;\n    float stepsPerSecond;\n    float speedup;\n};\n\n// Generate random car controls for testing\nCarControls GenerateRandomControls(std::mt19937& rng) {\n    std::uniform_real_distribution<float> dist(-1.0f, 1.0f);\n    std::uniform_real_distribution<float> boolDist(0.0f, 1.0f);\n    \n    CarControls controls;\n    controls.throttle = dist(rng);\n    controls.steer = dist(rng);\n    controls.pitch = dist(rng);\n    controls.yaw = dist(rng);\n    controls.roll = dist(rng);\n    controls.jump = boolDist(rng) > 0.8f;\n    controls.boost = boolDist(rng) > 0.7f;\n    controls.handbrake = boolDist(rng) > 0.9f;\n    \n    return controls;\n}\n\n// Benchmark regular Arena\nBenchmarkResults BenchmarkCpuArena(int numCars, int numSteps, int seed = 42) {\n    std::cout << \"\\n=== CPU Arena Benchmark ===\" << std::endl;\n    std::cout << \"Cars: \" << numCars << \", Steps: \" << numSteps << std::endl;\n    \n    // Initialize RocketSim\n    RocketSim::Init(\"./collision_meshes\", true);\n    \n    // Create arena\n    Arena* arena = Arena::Create(GameMode::SOCCAR);\n    \n    // Add cars\n    std::vector<Car*> cars;\n    for (int i = 0; i < numCars; i++) {\n        Team team = (i % 2 == 0) ? Team::BLUE : Team::ORANGE;\n        Car* car = arena->AddCar(team);\n        cars.push_back(car);\n    }\n    \n    // Generate random controls\n    std::mt19937 rng(seed);\n    std::vector<std::vector<CarControls>> allControls(numCars);\n    for (int i = 0; i < numCars; i++) {\n        allControls[i].reserve(numSteps);\n        for (int j = 0; j < numSteps; j++) {\n            allControls[i].push_back(GenerateRandomControls(rng));\n        }\n    }\n    \n    // Benchmark\n    auto startTime = std::chrono::high_resolution_clock::now();\n    \n    for (int step = 0; step < numSteps; step++) {\n        // Update controls\n        for (int i = 0; i < numCars; i++) {\n            cars[i]->controls = allControls[i][step];\n        }\n        \n        // Step simulation\n        arena->Step(1);\n        \n        if (step % 1000 == 0) {\n            std::cout << \"Progress: \" << (step * 100 / numSteps) << \"%\\r\" << std::flush;\n        }\n    }\n    \n    auto endTime = std::chrono::high_resolution_clock::now();\n    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(endTime - startTime);\n    \n    BenchmarkResults results;\n    results.totalTime = duration.count() / 1000.0f; // ms\n    results.totalSteps = numSteps;\n    results.avgStepTime = results.totalTime / numSteps;\n    results.stepsPerSecond = 1000.0f / results.avgStepTime;\n    results.speedup = 1.0f; // baseline\n    \n    std::cout << \"\\nCPU Results:\" << std::endl;\n    std::cout << \"  Total time: \" << results.totalTime << \" ms\" << std::endl;\n    std::cout << \"  Avg step time: \" << results.avgStepTime << \" ms\" << std::endl;\n    std::cout << \"  Steps per second: \" << results.stepsPerSecond << std::endl;\n    \n    delete arena;\n    return results;\n}\n\n#ifdef RS_CUDA_ENABLED\n// Benchmark CUDA Arena\nBenchmarkResults BenchmarkCudaArena(int numCars, int numSteps, int seed = 42) {\n    std::cout << \"\\n=== CUDA Arena Benchmark ===\" << std::endl;\n    std::cout << \"Cars: \" << numCars << \", Steps: \" << numSteps << std::endl;\n    \n    // Initialize RocketSim\n    RocketSim::Init(\"./collision_meshes\", true);\n    \n    // Create CUDA arena\n    ArenaCuda* arena = ArenaCuda::Create(GameMode::SOCCAR);\n    arena->EnableCudaAcceleration(true);\n    \n    // Preallocate memory for better performance\n    arena->PreallocateMemory(numCars, 1024);\n    \n    // Add cars\n    std::vector<Car*> cars;\n    for (int i = 0; i < numCars; i++) {\n        Team team = (i % 2 == 0) ? Team::BLUE : Team::ORANGE;\n        Car* car = arena->AddCar(team);\n        cars.push_back(car);\n    }\n    \n    // Generate random controls (same as CPU for fair comparison)\n    std::mt19937 rng(seed);\n    std::vector<std::vector<CarControls>> allControls(numCars);\n    for (int i = 0; i < numCars; i++) {\n        allControls[i].reserve(numSteps);\n        for (int j = 0; j < numSteps; j++) {\n            allControls[i].push_back(GenerateRandomControls(rng));\n        }\n    }\n    \n    // Warm up GPU\n    std::cout << \"Warming up GPU...\" << std::endl;\n    for (int i = 0; i < 100; i++) {\n        for (int j = 0; j < numCars; j++) {\n            cars[j]->controls = GenerateRandomControls(rng);\n        }\n        arena->Step(1);\n    }\n    \n    // Benchmark\n    auto startTime = std::chrono::high_resolution_clock::now();\n    \n    for (int step = 0; step < numSteps; step++) {\n        // Update controls\n        for (int i = 0; i < numCars; i++) {\n            cars[i]->controls = allControls[i][step];\n        }\n        \n        // Step simulation\n        arena->Step(1);\n        \n        if (step % 1000 == 0) {\n            std::cout << \"Progress: \" << (step * 100 / numSteps) << \"%\\r\" << std::flush;\n        }\n    }\n    \n    auto endTime = std::chrono::high_resolution_clock::now();\n    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(endTime - startTime);\n    \n    BenchmarkResults results;\n    results.totalTime = duration.count() / 1000.0f; // ms\n    results.totalSteps = numSteps;\n    results.avgStepTime = results.totalTime / numSteps;\n    results.stepsPerSecond = 1000.0f / results.avgStepTime;\n    results.speedup = 0.0f; // Will be calculated later\n    \n    std::cout << \"\\nCUDA Results:\" << std::endl;\n    std::cout << \"  Total time: \" << results.totalTime << \" ms\" << std::endl;\n    std::cout << \"  Avg step time: \" << results.avgStepTime << \" ms\" << std::endl;\n    std::cout << \"  Steps per second: \" << results.stepsPerSecond << std::endl;\n    std::cout << \"  CUDA avg step time: \" << arena->GetAverageStepTime() << \" ms\" << std::endl;\n    std::cout << \"  Arena speedup: \" << arena->GetSpeedup() << \"x\" << std::endl;\n    \n    delete arena;\n    return results;\n}\n\n// Benchmark batch processing\nvoid BenchmarkBatchProcessing(int numBatches, int numCars, int numSteps) {\n    std::cout << \"\\n=== Batch Processing Benchmark ===\" << std::endl;\n    std::cout << \"Batches: \" << numBatches << \", Cars per batch: \" << numCars << \", Steps: \" << numSteps << std::endl;\n    \n    // Create multiple arenas\n    std::vector<ArenaCuda*> arenas = CreateCudaArenasBatch(GameMode::SOCCAR, numBatches);\n    \n    // Add cars to each arena\n    std::mt19937 rng(42);\n    for (auto& arena : arenas) {\n        for (int i = 0; i < numCars; i++) {\n            Team team = (i % 2 == 0) ? Team::BLUE : Team::ORANGE;\n            arena->AddCar(team);\n        }\n    }\n    \n    // Generate batch controls\n    std::vector<std::vector<CarControls>> batchControls(numCars);\n    for (int i = 0; i < numCars; i++) {\n        batchControls[i].reserve(numSteps);\n        for (int j = 0; j < numSteps; j++) {\n            batchControls[i].push_back(GenerateRandomControls(rng));\n        }\n    }\n    \n    // Benchmark batch processing\n    auto startTime = std::chrono::high_resolution_clock::now();\n    \n    for (auto& arena : arenas) {\n        arena->BatchStep(batchControls, numSteps);\n    }\n    \n    SynchronizeAllCudaArenas(arenas);\n    \n    auto endTime = std::chrono::high_resolution_clock::now();\n    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(endTime - startTime);\n    \n    float totalTime = duration.count() / 1000.0f;\n    long long totalSimSteps = (long long)numBatches * numSteps;\n    float avgStepTime = totalTime / totalSimSteps;\n    \n    std::cout << \"Batch Results:\" << std::endl;\n    std::cout << \"  Total time: \" << totalTime << \" ms\" << std::endl;\n    std::cout << \"  Total simulation steps: \" << totalSimSteps << std::endl;\n    std::cout << \"  Avg step time: \" << avgStepTime << \" ms\" << std::endl;\n    std::cout << \"  Steps per second: \" << (1000.0f / avgStepTime) << std::endl;\n    \n    // Cleanup\n    for (auto& arena : arenas) {\n        delete arena;\n    }\n}\n#endif\n\nvoid PrintSystemInfo() {\n    std::cout << \"\\n=== System Information ===\" << std::endl;\n    \n#ifdef RS_CUDA_ENABLED\n    // Check CUDA device\n    int deviceCount;\n    cudaGetDeviceCount(&deviceCount);\n    \n    if (deviceCount > 0) {\n        cudaDeviceProp prop;\n        cudaGetDeviceProperties(&prop, 0);\n        \n        std::cout << \"CUDA Device: \" << prop.name << std::endl;\n        std::cout << \"CUDA Capability: \" << prop.major << \".\" << prop.minor << std::endl;\n        std::cout << \"Global Memory: \" << (prop.totalGlobalMem / 1024 / 1024) << \" MB\" << std::endl;\n        std::cout << \"Multiprocessors: \" << prop.multiProcessorCount << std::endl;\n        std::cout << \"Max Threads per Block: \" << prop.maxThreadsPerBlock << std::endl;\n    } else {\n        std::cout << \"No CUDA devices found\" << std::endl;\n    }\n#else\n    std::cout << \"CUDA support not compiled\" << std::endl;\n#endif\n}\n\nint main(int argc, char* argv[]) {\n    std::cout << \"RocketSim CUDA Performance Benchmark\" << std::endl;\n    std::cout << \"====================================\" << std::endl;\n    \n    PrintSystemInfo();\n    \n    // Benchmark parameters\n    std::vector<int> carCounts = {2, 6, 12, 24, 48};\n    int numSteps = 10000;\n    \n    std::cout << \"\\n=== Performance Comparison ===\" << std::endl;\n    std::cout << std::setw(8) << \"Cars\" \n              << std::setw(12) << \"CPU (ms)\" \n              << std::setw(12) << \"CUDA (ms)\" \n              << std::setw(10) << \"Speedup\"\n              << std::setw(15) << \"CPU Steps/s\"\n              << std::setw(15) << \"CUDA Steps/s\" << std::endl;\n    std::cout << std::string(72, '-') << std::endl;\n    \n    for (int numCars : carCounts) {\n        // Benchmark CPU\n        BenchmarkResults cpuResults = BenchmarkCpuArena(numCars, numSteps);\n        \n#ifdef RS_CUDA_ENABLED\n        // Benchmark CUDA\n        BenchmarkResults cudaResults = BenchmarkCudaArena(numCars, numSteps);\n        cudaResults.speedup = cpuResults.avgStepTime / cudaResults.avgStepTime;\n        \n        std::cout << std::setw(8) << numCars\n                  << std::setw(12) << std::fixed << std::setprecision(3) << cpuResults.avgStepTime\n                  << std::setw(12) << std::fixed << std::setprecision(3) << cudaResults.avgStepTime\n                  << std::setw(10) << std::fixed << std::setprecision(2) << cudaResults.speedup << \"x\"\n                  << std::setw(15) << std::fixed << std::setprecision(1) << cpuResults.stepsPerSecond\n                  << std::setw(15) << std::fixed << std::setprecision(1) << cudaResults.stepsPerSecond\n                  << std::endl;\n#else\n        std::cout << std::setw(8) << numCars\n                  << std::setw(12) << std::fixed << std::setprecision(3) << cpuResults.avgStepTime\n                  << std::setw(12) << \"N/A\"\n                  << std::setw(10) << \"N/A\"\n                  << std::setw(15) << std::fixed << std::setprecision(1) << cpuResults.stepsPerSecond\n                  << std::setw(15) << \"N/A\"\n                  << std::endl;\n#endif\n    }\n    \n#ifdef RS_CUDA_ENABLED\n    // Test batch processing\n    BenchmarkBatchProcessing(8, 6, 5000);\n    \n    std::cout << \"\\n=== Recommendations ===\" << std::endl;\n    std::cout << \"• For RL training with many parallel environments, use batch processing\" << std::endl;\n    std::cout << \"• CUDA acceleration is most effective with 12+ cars\" << std::endl;\n    std::cout << \"• Consider GPU memory when scaling up the number of simultaneous arenas\" << std::endl;\n    std::cout << \"• Use ArenaCuda::PreallocateMemory() for consistent performance\" << std::endl;\n#else\n    std::cout << \"\\nTo enable CUDA acceleration, compile with CUDA support enabled.\" << std::endl;\n#endif\n    \n    return 0;\n}\n"
