#include \"RocketSimCuda.h\"\n#include <iostream>\n#include <chrono>\n#include <algorithm>\n#include <numeric>\n\n#ifdef RS_CUDA_ENABLED\n#include <cuda_runtime.h>\n#endif\n\nnamespace RocketSim {\n\n#ifdef RS_CUDA_ENABLED\n\n// Static member definitions\nstd::map<std::string, std::vector<float>> CudaProfiler::timings;\nstd::map<std::string, std::chrono::high_resolution_clock::time_point> CudaProfiler::startTimes;\n\nvoid InitCuda(std::filesystem::path collisionMeshesFolder, bool silent) {\n    // Initialize regular RocketSim first\n    Init(collisionMeshesFolder, silent);\n    \n    // Check CUDA availability\n    if (!IsCudaAvailable()) {\n        if (!silent) {\n            std::cerr << \"CUDA not available, falling back to CPU simulation\" << std::endl;\n        }\n        return;\n    }\n    \n    if (!silent) {\n        CudaDeviceInfo info = GetCudaDeviceInfo();\n        std::cout << \"CUDA initialized with device: \" << info.name << std::endl;\n        std::cout << \"Compute capability: \" << info.major << \".\" << info.minor << std::endl;\n        std::cout << \"Total memory: \" << (info.totalMemory / 1024 / 1024) << \" MB\" << std::endl;\n    }\n}\n\nbool IsCudaAvailable() {\n    int deviceCount;\n    cudaError_t error = cudaGetDeviceCount(&deviceCount);\n    return (error == cudaSuccess && deviceCount > 0);\n}\n\nCudaDeviceInfo GetCudaDeviceInfo() {\n    CudaDeviceInfo info;\n    info.isAvailable = false;\n    \n    int deviceCount;\n    if (cudaGetDeviceCount(&deviceCount) != cudaSuccess || deviceCount == 0) {\n        return info;\n    }\n    \n    cudaDeviceProp prop;\n    if (cudaGetDeviceProperties(&prop, 0) == cudaSuccess) {\n        info.name = prop.name;\n        info.major = prop.major;\n        info.minor = prop.minor;\n        info.totalMemory = prop.totalGlobalMem;\n        info.multiprocessorCount = prop.multiProcessorCount;\n        info.maxThreadsPerBlock = prop.maxThreadsPerBlock;\n        info.isAvailable = true;\n    }\n    \n    return info;\n}\n\n// CudaProfiler implementation\nvoid CudaProfiler::BeginProfile(const std::string& name) {\n    startTimes[name] = std::chrono::high_resolution_clock::now();\n}\n\nvoid CudaProfiler::EndProfile(const std::string& name) {\n    auto endTime = std::chrono::high_resolution_clock::now();\n    auto it = startTimes.find(name);\n    if (it != startTimes.end()) {\n        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(endTime - it->second);\n        timings[name].push_back(duration.count() / 1000.0f); // Convert to milliseconds\n    }\n}\n\nvoid CudaProfiler::PrintResults() {\n    std::cout << \"\\n=== CUDA Profiling Results ===\" << std::endl;\n    for (const auto& timing : timings) {\n        const std::string& name = timing.first;\n        const std::vector<float>& times = timing.second;\n        \n        if (!times.empty()) {\n            float avgTime = std::accumulate(times.begin(), times.end(), 0.0f) / times.size();\n            float minTime = *std::min_element(times.begin(), times.end());\n            float maxTime = *std::max_element(times.begin(), times.end());\n            \n            std::cout << name << \":\" << std::endl;\n            std::cout << \"  Avg: \" << avgTime << \" ms\" << std::endl;\n            std::cout << \"  Min: \" << minTime << \" ms\" << std::endl;\n            std::cout << \"  Max: \" << maxTime << \" ms\" << std::endl;\n            std::cout << \"  Calls: \" << times.size() << std::endl;\n        }\n    }\n}\n\nvoid CudaProfiler::Reset() {\n    timings.clear();\n    startTimes.clear();\n}\n\n// CudaMemoryManager implementation\nsize_t CudaMemoryManager::GetAvailableMemory() {\n    size_t free, total;\n    if (cudaMemGetInfo(&free, &total) == cudaSuccess) {\n        return free;\n    }\n    return 0;\n}\n\nsize_t CudaMemoryManager::GetUsedMemory() {\n    size_t free, total;\n    if (cudaMemGetInfo(&free, &total) == cudaSuccess) {\n        return total - free;\n    }\n    return 0;\n}\n\nvoid CudaMemoryManager::OptimizeMemoryUsage() {\n    // Trigger garbage collection and memory optimization\n    cudaDeviceSynchronize();\n    cudaError_t error = cudaDeviceReset();\n    if (error != cudaSuccess) {\n        std::cerr << \"Failed to reset CUDA device: \" << cudaGetErrorString(error) << std::endl;\n    }\n}\n\nvoid CudaMemoryManager::SetMemoryPoolSize(size_t sizeBytes) {\n    // Set memory pool size for better allocation performance\n    // This is a placeholder - actual implementation would depend on CUDA version\n    std::cout << \"Setting CUDA memory pool size to \" << (sizeBytes / 1024 / 1024) << \" MB\" << std::endl;\n}\n\n// BatchProcessor implementation\nBatchProcessor::BatchProcessor(int numArenas, GameMode gameMode) \n    : numArenas(numArenas), gameMode(gameMode) {\n    \n    arenas = CreateCudaArenasBatch(gameMode, numArenas);\n    \n    std::cout << \"Created \" << numArenas << \" CUDA arenas for batch processing\" << std::endl;\n}\n\nBatchProcessor::~BatchProcessor() {\n    for (auto& arena : arenas) {\n        delete arena;\n    }\n}\n\nvoid BatchProcessor::AddCarsToAllArenas(int numCars) {\n    for (auto& arena : arenas) {\n        for (int i = 0; i < numCars; i++) {\n            Team team = (i % 2 == 0) ? Team::BLUE : Team::ORANGE;\n            arena->AddCar(team);\n        }\n    }\n}\n\nvoid BatchProcessor::ResetAllArenas(int seed) {\n    for (int i = 0; i < arenas.size(); i++) {\n        arenas[i]->ResetToRandomKickoff(seed + i);\n    }\n}\n\nvoid BatchProcessor::StepAllArenas(const std::vector<std::vector<CarControls>>& controlsPerArena, int ticks) {\n    for (int i = 0; i < arenas.size() && i < controlsPerArena.size(); i++) {\n        std::vector<std::vector<CarControls>> batchControls;\n        \n        // Convert single step controls to batch format\n        int numCars = arenas[i]->GetCars().size();\n        batchControls.resize(numCars);\n        \n        for (int j = 0; j < numCars && j < controlsPerArena[i].size(); j++) {\n            batchControls[j].resize(ticks, controlsPerArena[i][j]);\n        }\n        \n        arenas[i]->BatchStep(batchControls, ticks);\n    }\n}\n\nstd::vector<std::vector<CarState>> BatchProcessor::GetAllCarStates() {\n    std::vector<std::vector<CarState>> allStates;\n    allStates.reserve(arenas.size());\n    \n    for (auto& arena : arenas) {\n        std::vector<CarState> arenaStates;\n        for (Car* car : arena->GetCars()) {\n            arenaStates.push_back(car->GetState());\n        }\n        allStates.push_back(arenaStates);\n    }\n    \n    return allStates;\n}\n\nstd::vector<BallState> BatchProcessor::GetAllBallStates() {\n    std::vector<BallState> allStates;\n    allStates.reserve(arenas.size());\n    \n    for (auto& arena : arenas) {\n        allStates.push_back(arena->ball->GetState());\n    }\n    \n    return allStates;\n}\n\nfloat BatchProcessor::GetAverageStepTime() const {\n    float totalTime = 0.0f;\n    int count = 0;\n    \n    for (auto& arena : arenas) {\n        if (arena->GetTotalSteps() > 0) {\n            totalTime += arena->GetAverageStepTime();\n            count++;\n        }\n    }\n    \n    return count > 0 ? totalTime / count : 0.0f;\n}\n\nfloat BatchProcessor::GetTotalSpeedup() const {\n    float totalSpeedup = 0.0f;\n    int count = 0;\n    \n    for (auto& arena : arenas) {\n        float speedup = arena->GetSpeedup();\n        if (speedup > 0) {\n            totalSpeedup += speedup;\n            count++;\n        }\n    }\n    \n    return count > 0 ? totalSpeedup / count : 1.0f;\n}\n\n// RLTrainingInterface implementation\nRLTrainingInterface::RLTrainingInterface(const TrainingConfig& config) \n    : config(config), totalStepTime(0.0f), totalSteps(0) {\n    \n    batchProcessor = std::make_unique<BatchProcessor>(config.numEnvironments, config.gameMode);\n    batchProcessor->AddCarsToAllArenas(config.numCarsPerEnvironment);\n    \n    // Set default functions\n    rewardFunction = [this](const CarState& car, const BallState& ball, const std::vector<CarState>& allCars) {\n        return DefaultRewardFunction(car, ball, allCars);\n    };\n    \n    observationFunction = [this](const CarState& car, const BallState& ball, const std::vector<CarState>& allCars) {\n        return DefaultObservationFunction(car, ball, allCars);\n    };\n    \n    lastStepTime = std::chrono::high_resolution_clock::now();\n    \n    std::cout << \"RL Training Interface initialized with \" << config.numEnvironments \n              << \" environments, \" << config.numCarsPerEnvironment << \" cars each\" << std::endl;\n}\n\nRLTrainingInterface::~RLTrainingInterface() {\n    if (config.enableProfiling) {\n        PrintPerformanceStats();\n    }\n}\n\nRLTrainingInterface::StepResult RLTrainingInterface::Step(const std::vector<std::vector<CarControls>>& actions) {\n    auto stepStartTime = std::chrono::high_resolution_clock::now();\n    \n    // Perform simulation step\n    batchProcessor->StepAllArenas(actions, 1);\n    \n    // Get new states\n    auto carStates = batchProcessor->GetAllCarStates();\n    auto ballStates = batchProcessor->GetAllBallStates();\n    \n    StepResult result;\n    result.observations.resize(config.numEnvironments);\n    result.rewards.resize(config.numEnvironments);\n    result.dones.resize(config.numEnvironments, false);\n    result.infos.resize(config.numEnvironments);\n    \n    // Calculate observations and rewards\n    for (int env = 0; env < config.numEnvironments; env++) {\n        result.observations[env].resize(config.numCarsPerEnvironment);\n        result.rewards[env].resize(config.numCarsPerEnvironment);\n        \n        for (int car = 0; car < config.numCarsPerEnvironment && car < carStates[env].size(); car++) {\n            // Get observation\n            auto obs = observationFunction(carStates[env][car], ballStates[env], carStates[env]);\n            result.observations[env][car] = obs.size(); // Placeholder - would contain actual obs values\n            \n            // Calculate reward\n            if (config.useRewards) {\n                result.rewards[env][car] = rewardFunction(carStates[env][car], ballStates[env], carStates[env]);\n            } else {\n                result.rewards[env][car] = 0.0f;\n            }\n        }\n        \n        // Check if episode is done (goal scored, timeout, etc.)\n        // This is a simplified check - you'd implement proper episode termination logic\n        result.dones[env] = false; // Placeholder\n        \n        // Additional info\n        result.infos[env][\"ball_height\"] = ballStates[env].pos.z;\n        result.infos[env][\"avg_car_speed\"] = 0.0f; // Calculate average\n    }\n    \n    // Update performance tracking\n    auto stepEndTime = std::chrono::high_resolution_clock::now();\n    auto stepDuration = std::chrono::duration_cast<std::chrono::microseconds>(stepEndTime - stepStartTime);\n    totalStepTime += stepDuration.count() / 1000.0f;\n    totalSteps++;\n    \n    return result;\n}\n\nstd::vector<std::vector<float>> RLTrainingInterface::Reset(const std::vector<int>& envIndices) {\n    if (envIndices.empty()) {\n        // Reset all environments\n        batchProcessor->ResetAllArenas();\n    } else {\n        // Reset specific environments - would need arena-specific reset\n        for (int idx : envIndices) {\n            if (idx >= 0 && idx < config.numEnvironments) {\n                // Reset specific arena\n            }\n        }\n    }\n    \n    return GetObservations();\n}\n\nstd::vector<std::vector<float>> RLTrainingInterface::GetObservations() {\n    auto carStates = batchProcessor->GetAllCarStates();\n    auto ballStates = batchProcessor->GetAllBallStates();\n    \n    std::vector<std::vector<float>> observations(config.numEnvironments);\n    \n    for (int env = 0; env < config.numEnvironments; env++) {\n        observations[env].resize(config.numCarsPerEnvironment);\n        \n        for (int car = 0; car < config.numCarsPerEnvironment && car < carStates[env].size(); car++) {\n            auto obs = observationFunction(carStates[env][car], ballStates[env], carStates[env]);\n            observations[env][car] = obs.size(); // Placeholder\n        }\n    }\n    \n    return observations;\n}\n\nvoid RLTrainingInterface::SetRewardFunction(std::function<float(const CarState&, const BallState&, const std::vector<CarState>&)> rewardFn) {\n    rewardFunction = rewardFn;\n}\n\nvoid RLTrainingInterface::SetObservationFunction(std::function<std::vector<float>(const CarState&, const BallState&, const std::vector<CarState>&)> obsFn) {\n    observationFunction = obsFn;\n}\n\nfloat RLTrainingInterface::GetStepsPerSecond() const {\n    if (totalSteps > 0 && totalStepTime > 0) {\n        return (totalSteps * 1000.0f) / totalStepTime; // Convert ms to seconds\n    }\n    return 0.0f;\n}\n\nvoid RLTrainingInterface::PrintPerformanceStats() {\n    std::cout << \"\\n=== RL Training Performance Stats ===\" << std::endl;\n    std::cout << \"Total steps: \" << totalSteps << std::endl;\n    std::cout << \"Total time: \" << totalStepTime << \" ms\" << std::endl;\n    std::cout << \"Average step time: \" << (totalStepTime / totalSteps) << \" ms\" << std::endl;\n    std::cout << \"Steps per second: \" << GetStepsPerSecond() << std::endl;\n    std::cout << \"Batch processor speedup: \" << batchProcessor->GetTotalSpeedup() << \"x\" << std::endl;\n}\n\nfloat RLTrainingInterface::DefaultRewardFunction(const CarState& car, const BallState& ball, const std::vector<CarState>& allCars) {\n    float reward = 0.0f;\n    \n    // Distance to ball reward (negative)\n    Vec carToBall = ball.pos - car.pos;\n    float distToBall = carToBall.Length();\n    reward -= distToBall * 0.001f;\n    \n    // Speed reward\n    float speed = car.vel.Length();\n    reward += speed * 0.01f;\n    \n    // Ball touch reward (simplified)\n    if (distToBall < 200.0f) {\n        reward += 10.0f;\n    }\n    \n    return reward;\n}\n\nstd::vector<float> RLTrainingInterface::DefaultObservationFunction(const CarState& car, const BallState& ball, const std::vector<CarState>& allCars) {\n    std::vector<float> obs;\n    obs.reserve(35); // Standard observation size\n    \n    // Car position (relative to field center)\n    obs.push_back(car.pos.x / 4096.0f);\n    obs.push_back(car.pos.y / 5120.0f);\n    obs.push_back(car.pos.z / 2044.0f);\n    \n    // Car velocity\n    obs.push_back(car.vel.x / 2300.0f);\n    obs.push_back(car.vel.y / 2300.0f);\n    obs.push_back(car.vel.z / 2300.0f);\n    \n    // Car rotation (forward and up vectors)\n    Vec forward = car.rotMat.forward;\n    Vec up = car.rotMat.up;\n    obs.push_back(forward.x);\n    obs.push_back(forward.y);\n    obs.push_back(forward.z);\n    obs.push_back(up.x);\n    obs.push_back(up.y);\n    obs.push_back(up.z);\n    \n    // Car angular velocity\n    obs.push_back(car.angVel.x / 5.5f);\n    obs.push_back(car.angVel.y / 5.5f);\n    obs.push_back(car.angVel.z / 5.5f);\n    \n    // Car state\n    obs.push_back(car.isOnGround ? 1.0f : 0.0f);\n    obs.push_back(car.hasJumped ? 1.0f : 0.0f);\n    obs.push_back(car.hasDoubleJumped ? 1.0f : 0.0f);\n    obs.push_back(car.hasFlipped ? 1.0f : 0.0f);\n    obs.push_back(car.boost / 100.0f);\n    \n    // Ball position (relative to car)\n    Vec ballRelPos = ball.pos - car.pos;\n    obs.push_back(ballRelPos.x / 4096.0f);\n    obs.push_back(ballRelPos.y / 5120.0f);\n    obs.push_back(ballRelPos.z / 2044.0f);\n    \n    // Ball velocity\n    obs.push_back(ball.vel.x / 6000.0f);\n    obs.push_back(ball.vel.y / 6000.0f);\n    obs.push_back(ball.vel.z / 6000.0f);\n    \n    // Ball angular velocity\n    obs.push_back(ball.angVel.x / 6.0f);\n    obs.push_back(ball.angVel.y / 6.0f);\n    obs.push_back(ball.angVel.z / 6.0f);\n    \n    // Previous actions (would need to be tracked)\n    for (int i = 0; i < 8; i++) {\n        obs.push_back(0.0f); // Placeholder for previous actions\n    }\n    \n    return obs;\n}\n\n// RLUtils implementation\nnamespace RLUtils {\n    \nstd::vector<float> GameStateToObservation(const CarState& car, const BallState& ball, const std::vector<CarState>& otherCars) {\n    // Use the default observation function\n    RLTrainingInterface::TrainingConfig config;\n    RLTrainingInterface interface(config);\n    return interface.DefaultObservationFunction(car, ball, otherCars);\n}\n\nfloat BallTouchReward(const CarState& car, const BallState& ball) {\n    Vec carToBall = ball.pos - car.pos;\n    float distance = carToBall.Length();\n    \n    if (distance < 150.0f) {\n        return 100.0f; // Large reward for touching ball\n    }\n    return 0.0f;\n}\n\nfloat GoalReward(const CarState& car, const BallState& ball, Team carTeam) {\n    // Check if ball is in goal\n    bool inGoal = (ball.pos.z < 642.775f && std::abs(ball.pos.x) < 892.755f);\n    \n    if (inGoal) {\n        // Determine which goal\n        bool orangeGoal = ball.pos.y > 5120.0f;\n        bool blueGoal = ball.pos.y < -5120.0f;\n        \n        if ((carTeam == Team::BLUE && orangeGoal) || (carTeam == Team::ORANGE && blueGoal)) {\n            return 1000.0f; // Huge reward for scoring\n        } else {\n            return -1000.0f; // Huge penalty for own goal\n        }\n    }\n    \n    return 0.0f;\n}\n\nfloat VelocityReward(const CarState& car, const BallState& ball) {\n    Vec carToBall = ball.pos - car.pos;\n    carToBall = carToBall.Normalized();\n    \n    float velocityTowardBall = car.vel.Dot(carToBall);\n    return velocityTowardBall * 0.01f;\n}\n\nfloat DistanceToBallReward(const CarState& car, const BallState& ball) {\n    Vec carToBall = ball.pos - car.pos;\n    float distance = carToBall.Length();\n    \n    // Inverse distance reward (closer = better)\n    return 1000.0f / (distance + 100.0f);\n}\n\nCarControls DiscreteToCarControls(int action, int numActions) {\n    // Standard Rocket League discrete action space\n    // This is a simplified version - full implementation would have 373 actions\n    \n    CarControls controls;\n    \n    if (action < 5) {\n        // Throttle only\n        controls.throttle = (action - 2) * 0.5f; // -1, -0.5, 0, 0.5, 1\n    } else if (action < 10) {\n        // Steer only\n        controls.steer = (action - 7) * 0.5f;\n    } else if (action < 15) {\n        // Combined throttle + steer\n        controls.throttle = 1.0f;\n        controls.steer = (action - 12) * 0.5f;\n    } else if (action < 20) {\n        // Jump actions\n        controls.jump = true;\n        controls.throttle = (action - 17) * 0.5f;\n    } else {\n        // Boost actions\n        controls.boost = true;\n        controls.throttle = 1.0f;\n    }\n    \n    return controls;\n}\n\nint CarControlsToDiscrete(const CarControls& controls, int numActions) {\n    // Convert CarControls back to discrete action\n    // This is a simplified mapping\n    \n    if (controls.boost) return 20;\n    if (controls.jump) return 15;\n    if (std::abs(controls.steer) > 0.1f) return 7 + (int)(controls.steer * 2);\n    return 2 + (int)(controls.throttle * 2);\n}\n\nvoid NormalizeObservation(std::vector<float>& obs) {\n    // Observations are already normalized in the observation function\n    // This could apply additional normalization if needed\n}\n\nvoid DenormalizeAction(std::vector<float>& action) {\n    // Convert normalized action values back to CarControls range\n    for (float& val : action) {\n        val = std::clamp(val, -1.0f, 1.0f);\n    }\n}\n\n} // namespace RLUtils\n\n#endif // RS_CUDA_ENABLED\n\n} // namespace RocketSim\n"
