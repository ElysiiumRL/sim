#pragma once\n\n// Include the original RocketSim functionality\n#include \"RocketSim.h\"\n\n// CUDA-specific includes\n#ifdef RS_CUDA_ENABLED\n#include \"Sim/Arena/ArenaCuda.h\"\n#include \"Sim/CudaPhysics/CudaPhysicsEngine.cuh\"\n#include \"Math/CudaMath.cuh\"\n#endif\n\n// Enhanced RocketSim namespace with CUDA support\nnamespace RocketSim {\n\n#ifdef RS_CUDA_ENABLED\n    // CUDA-specific initialization\n    void InitCuda(std::filesystem::path collisionMeshesFolder, bool silent = false);\n    \n    // Check if CUDA is available and working\n    bool IsCudaAvailable();\n    \n    // Get CUDA device information\n    struct CudaDeviceInfo {\n        std::string name;\n        int major, minor; // Compute capability\n        size_t totalMemory;\n        int multiprocessorCount;\n        int maxThreadsPerBlock;\n        bool isAvailable;\n    };\n    \n    CudaDeviceInfo GetCudaDeviceInfo();\n    \n    // Performance profiler for CUDA operations\n    class CudaProfiler {\n    public:\n        static void BeginProfile(const std::string& name);\n        static void EndProfile(const std::string& name);\n        static void PrintResults();\n        static void Reset();\n        \n    private:\n        static std::map<std::string, std::vector<float>> timings;\n        static std::map<std::string, std::chrono::high_resolution_clock::time_point> startTimes;\n    };\n    \n    // Memory management utilities\n    class CudaMemoryManager {\n    public:\n        static size_t GetAvailableMemory();\n        static size_t GetUsedMemory();\n        static void OptimizeMemoryUsage();\n        static void SetMemoryPoolSize(size_t sizeBytes);\n    };\n    \n    // Batch processing utilities for RL training\n    class BatchProcessor {\n    public:\n        BatchProcessor(int numArenas, GameMode gameMode = GameMode::SOCCAR);\n        ~BatchProcessor();\n        \n        // Add cars to all arenas\n        void AddCarsToAllArenas(int numCars);\n        \n        // Reset all arenas to kickoff\n        void ResetAllArenas(int seed = -1);\n        \n        // Step all arenas with different controls\n        void StepAllArenas(const std::vector<std::vector<CarControls>>& controlsPerArena, int ticks = 1);\n        \n        // Get states from all arenas\n        std::vector<std::vector<CarState>> GetAllCarStates();\n        std::vector<BallState> GetAllBallStates();\n        \n        // Performance monitoring\n        float GetAverageStepTime() const;\n        float GetTotalSpeedup() const;\n        \n    private:\n        std::vector<ArenaCuda*> arenas;\n        int numArenas;\n        GameMode gameMode;\n    };\n    \n    // High-level RL training interface\n    class RLTrainingInterface {\n    public:\n        struct TrainingConfig {\n            int numEnvironments = 16;\n            int numCarsPerEnvironment = 6;\n            GameMode gameMode = GameMode::SOCCAR;\n            float tickRate = 120.0f;\n            bool useRewards = true;\n            bool trackCollisions = true;\n            bool enableProfiling = false;\n        };\n        \n        RLTrainingInterface(const TrainingConfig& config);\n        ~RLTrainingInterface();\n        \n        // Training step: apply actions and get observations\n        struct StepResult {\n            std::vector<std::vector<float>> observations; // [env][car][obs]\n            std::vector<std::vector<float>> rewards;      // [env][car]\n            std::vector<bool> dones;                      // [env]\n            std::vector<std::map<std::string, float>> infos; // [env]\n        };\n        \n        StepResult Step(const std::vector<std::vector<CarControls>>& actions);\n        \n        // Reset environments\n        std::vector<std::vector<float>> Reset(const std::vector<int>& envIndices = {});\n        \n        // Get current observations\n        std::vector<std::vector<float>> GetObservations();\n        \n        // Configuration\n        void SetRewardFunction(std::function<float(const CarState&, const BallState&, const std::vector<CarState>&)> rewardFn);\n        void SetObservationFunction(std::function<std::vector<float>(const CarState&, const BallState&, const std::vector<CarState>&)> obsFn);\n        \n        // Performance monitoring\n        float GetStepsPerSecond() const;\n        void PrintPerformanceStats();\n        \n    private:\n        TrainingConfig config;\n        std::unique_ptr<BatchProcessor> batchProcessor;\n        \n        std::function<float(const CarState&, const BallState&, const std::vector<CarState>&)> rewardFunction;\n        std::function<std::vector<float>(const CarState&, const BallState&, const std::vector<CarState>&)> observationFunction;\n        \n        // Default reward and observation functions\n        float DefaultRewardFunction(const CarState& car, const BallState& ball, const std::vector<CarState>& allCars);\n        std::vector<float> DefaultObservationFunction(const CarState& car, const BallState& ball, const std::vector<CarState>& allCars);\n        \n        // Performance tracking\n        mutable std::chrono::high_resolution_clock::time_point lastStepTime;\n        mutable float totalStepTime;\n        mutable long long totalSteps;\n    };\n    \n    // Utility functions for common RL operations\n    namespace RLUtils {\n        // Convert game state to standard observation format\n        std::vector<float> GameStateToObservation(const CarState& car, const BallState& ball, const std::vector<CarState>& otherCars);\n        \n        // Common reward functions\n        float BallTouchReward(const CarState& car, const BallState& ball);\n        float GoalReward(const CarState& car, const BallState& ball, Team carTeam);\n        float VelocityReward(const CarState& car, const BallState& ball);\n        float DistanceToBallReward(const CarState& car, const BallState& ball);\n        \n        // Action space utilities\n        CarControls DiscreteToCarControls(int action, int numActions = 373); // Standard RL action space\n        int CarControlsToDiscrete(const CarControls& controls, int numActions = 373);\n        \n        // State normalization\n        void NormalizeObservation(std::vector<float>& obs);\n        void DenormalizeAction(std::vector<float>& action);\n    }\n    \n#else\n    // Stub functions when CUDA is not available\n    inline bool IsCudaAvailable() { return false; }\n    inline void InitCuda(std::filesystem::path, bool = false) { \n        std::cerr << \"CUDA support not compiled. Use regular Init() function.\" << std::endl;\n    }\n#endif\n\n} // namespace RocketSim\n"
