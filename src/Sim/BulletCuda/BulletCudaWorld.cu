#include "BulletCudaWorld.cuh"\n#include <iostream>\n#include <chrono>\n\n#ifdef RS_CUDA_ENABLED\n\nnamespace RocketSim {\nnamespace BulletCuda {\n\nBulletCudaWorld::BulletCudaWorld(int maxBodies, int maxContacts, int maxConstraints)\n    : maxBodies(maxBodies), maxContacts(maxContacts), maxConstraints(maxConstraints),\n      numBodies(0), numShapes(0), numConstraints(0),\n      meshVertexCount(0), meshIndexCount(0),\n      d_bodies(nullptr), d_shapes(nullptr), d_contacts(nullptr), d_constraints(nullptr),\n      d_meshVertices(nullptr), d_meshIndices(nullptr),\n      lastStepTime(0.0f), stepCount(0) {\n    \n    h_gravity = CudaMath::CudaVec3(0, 0, -650.0f); // RL gravity\n    \n    // Reserve host memory\n    h_bodies.reserve(maxBodies);\n    h_shapes.reserve(64); // Reasonable number of collision shapes\n    h_contacts.reserve(maxContacts);\n    h_constraints.reserve(maxConstraints);\n}\n\nBulletCudaWorld::~BulletCudaWorld() {\n    Cleanup();\n}\n\nbool BulletCudaWorld::Initialize() {\n    // Create CUDA streams for maximum parallelism\n    if (cudaStreamCreate(&integrationStream) != cudaSuccess ||\n        cudaStreamCreate(&collisionStream) != cudaSuccess ||\n        cudaStreamCreate(&constraintStream) != cudaSuccess) {\n        std::cerr << \"Failed to create CUDA streams\" << std::endl;\n        return false;\n    }\n    \n    // Allocate device memory\n    if (cudaMalloc(&d_bodies, maxBodies * sizeof(CudaRigidBody)) != cudaSuccess ||\n        cudaMalloc(&d_shapes, 64 * sizeof(CudaCollisionShape)) != cudaSuccess ||\n        cudaMalloc(&d_contacts, maxContacts * sizeof(CudaContactPoint)) != cudaSuccess ||\n        cudaMalloc(&d_constraints, maxConstraints * sizeof(CudaConstraint)) != cudaSuccess) {\n        std::cerr << \"Failed to allocate CUDA memory for physics world\" << std::endl;\n        return false;\n    }\n    \n    // Create timing events\n    if (cudaEventCreate(&startEvent) != cudaSuccess ||\n        cudaEventCreate(&stopEvent) != cudaSuccess) {\n        std::cerr << \"Failed to create CUDA events\" << std::endl;\n        return false;\n    }\n    \n    // Initialize memory\n    cudaMemset(d_bodies, 0, maxBodies * sizeof(CudaRigidBody));\n    cudaMemset(d_shapes, 0, 64 * sizeof(CudaCollisionShape));\n    cudaMemset(d_contacts, 0, maxContacts * sizeof(CudaContactPoint));\n    cudaMemset(d_constraints, 0, maxConstraints * sizeof(CudaConstraint));\n    \n    std::cout << \"CUDA Bullet Physics World initialized (\" << maxBodies << \" bodies, \" \n              << maxContacts << \" contacts)\" << std::endl;\n    \n    return CheckCudaError(\"Initialize\");\n}\n\nvoid BulletCudaWorld::Cleanup() {\n    // Free device memory\n    if (d_bodies) { cudaFree(d_bodies); d_bodies = nullptr; }\n    if (d_shapes) { cudaFree(d_shapes); d_shapes = nullptr; }\n    if (d_contacts) { cudaFree(d_contacts); d_contacts = nullptr; }\n    if (d_constraints) { cudaFree(d_constraints); d_constraints = nullptr; }\n    if (d_meshVertices) { cudaFree(d_meshVertices); d_meshVertices = nullptr; }\n    if (d_meshIndices) { cudaFree(d_meshIndices); d_meshIndices = nullptr; }\n    \n    // Destroy streams\n    if (integrationStream) { cudaStreamDestroy(integrationStream); }\n    if (collisionStream) { cudaStreamDestroy(collisionStream); }\n    if (constraintStream) { cudaStreamDestroy(constraintStream); }\n    \n    // Destroy events\n    if (startEvent) { cudaEventDestroy(startEvent); }\n    if (stopEvent) { cudaEventDestroy(stopEvent); }\n}\n\nint BulletCudaWorld::AddRigidBody(const CudaRigidBody& body) {\n    if (numBodies >= maxBodies) {\n        std::cerr << \"Cannot add more rigid bodies, max reached: \" << maxBodies << std::endl;\n        return -1;\n    }\n    \n    int bodyId = numBodies++;\n    h_bodies.push_back(body);\n    \n    // Upload to GPU\n    cudaMemcpyAsync(&d_bodies[bodyId], &body, sizeof(CudaRigidBody),\n                    cudaMemcpyHostToDevice, integrationStream);\n    \n    return bodyId;\n}\n\nvoid BulletCudaWorld::RemoveRigidBody(int bodyId) {\n    if (bodyId < 0 || bodyId >= numBodies) return;\n    \n    // Mark as inactive\n    h_bodies[bodyId].isActive = false;\n    \n    // Update on GPU\n    cudaMemcpyAsync(&d_bodies[bodyId].isActive, &h_bodies[bodyId].isActive, sizeof(bool),\n                    cudaMemcpyHostToDevice, integrationStream);\n}\n\nvoid BulletCudaWorld::UpdateRigidBody(int bodyId, const CudaRigidBody& body) {\n    if (bodyId < 0 || bodyId >= numBodies) return;\n    \n    h_bodies[bodyId] = body;\n    \n    // Upload to GPU\n    cudaMemcpyAsync(&d_bodies[bodyId], &body, sizeof(CudaRigidBody),\n                    cudaMemcpyHostToDevice, integrationStream);\n}\n\nCudaRigidBody BulletCudaWorld::GetRigidBody(int bodyId) {\n    if (bodyId < 0 || bodyId >= numBodies) {\n        return CudaRigidBody{};\n    }\n    \n    CudaRigidBody body;\n    cudaMemcpyAsync(&body, &d_bodies[bodyId], sizeof(CudaRigidBody),\n                    cudaMemcpyDeviceToHost, integrationStream);\n    cudaStreamSynchronize(integrationStream);\n    \n    return body;\n}\n\nint BulletCudaWorld::AddCollisionShape(const CudaCollisionShape& shape) {\n    if (numShapes >= 64) {\n        std::cerr << \"Cannot add more collision shapes, max reached: 64\" << std::endl;\n        return -1;\n    }\n    \n    int shapeId = numShapes++;\n    h_shapes.push_back(shape);\n    \n    // Upload to GPU\n    cudaMemcpyAsync(&d_shapes[shapeId], &shape, sizeof(CudaCollisionShape),\n                    cudaMemcpyHostToDevice, collisionStream);\n    \n    return shapeId;\n}\n\nvoid BulletCudaWorld::SetMeshData(const std::vector<float>& vertices, const std::vector<int>& indices) {\n    meshVertexCount = vertices.size() / 3;\n    meshIndexCount = indices.size();\n    \n    // Allocate GPU memory for mesh data\n    if (d_meshVertices) cudaFree(d_meshVertices);\n    if (d_meshIndices) cudaFree(d_meshIndices);\n    \n    cudaMalloc(&d_meshVertices, vertices.size() * sizeof(float));\n    cudaMalloc(&d_meshIndices, indices.size() * sizeof(int));\n    \n    // Upload mesh data\n    cudaMemcpyAsync(d_meshVertices, vertices.data(), vertices.size() * sizeof(float),\n                    cudaMemcpyHostToDevice, collisionStream);\n    cudaMemcpyAsync(d_meshIndices, indices.data(), indices.size() * sizeof(int),\n                    cudaMemcpyHostToDevice, collisionStream);\n}\n\n// THIS IS THE MAIN REPLACEMENT FOR BULLET PHYSICS!\nvoid BulletCudaWorld::StepSimulation(float deltaTime, int maxSubSteps, float fixedTimeStep) {\n    cudaEventRecord(startEvent, 0);\n    \n    // For RL training, we typically use fixed timestep\n    float timeStep = (maxSubSteps > 1) ? fixedTimeStep : deltaTime;\n    int subSteps = (maxSubSteps > 1) ? maxSubSteps : 1;\n    \n    for (int subStep = 0; subStep < subSteps; subStep++) {\n        // 1. INTEGRATION PHASE - Replace Bullet's integration\n        LaunchIntegrationKernel(\n            d_bodies,\n            numBodies,\n            h_gravity,\n            timeStep,\n            integrationStream\n        );\n        \n        // 2. BROAD PHASE COLLISION DETECTION - Replace Bullet's broadphase\n        LaunchBroadPhaseKernel(\n            d_bodies,\n            d_shapes,\n            d_contacts,\n            numBodies,\n            maxContacts,\n            collisionStream\n        );\n        \n        // Sync before narrow phase\n        cudaStreamSynchronize(integrationStream);\n        cudaStreamSynchronize(collisionStream);\n        \n        // Get number of potential contacts\n        int numPotentialContacts;\n        cudaMemcpyAsync(&numPotentialContacts, &d_contacts[0].distance, sizeof(int),\n                        cudaMemcpyDeviceToHost, collisionStream);\n        cudaStreamSynchronize(collisionStream);\n        \n        numPotentialContacts = std::min(numPotentialContacts, maxContacts - 1);\n        \n        if (numPotentialContacts > 0) {\n            // 3. NARROW PHASE COLLISION DETECTION - Replace Bullet's narrow phase\n            LaunchNarrowPhaseKernel(\n                d_bodies,\n                d_shapes,\n                d_contacts,\n                d_meshVertices,\n                d_meshIndices,\n                numBodies,\n                numPotentialContacts,\n                collisionStream\n            );\n            \n            // 4. CONSTRAINT SOLVING - Replace Bullet's constraint solver\n            LaunchConstraintSolverKernel(\n                d_bodies,\n                d_contacts,\n                d_constraints,\n                numBodies,\n                numPotentialContacts,\n                numConstraints,\n                timeStep,\n                4, // 4 solver iterations (good balance of accuracy/speed)\n                constraintStream\n            );\n        }\n        \n        // 5. ROCKET LEAGUE SPECIFIC OPTIMIZATIONS\n        LaunchRocketLeaguePhysicsKernel(\n            d_bodies,\n            d_contacts,\n            numBodies,\n            numPotentialContacts,\n            timeStep,\n            integrationStream\n        );\n        \n        // Synchronize all streams\n        cudaStreamSynchronize(integrationStream);\n        cudaStreamSynchronize(collisionStream);\n        cudaStreamSynchronize(constraintStream);\n    }\n    \n    cudaEventRecord(stopEvent, 0);\n    cudaEventSynchronize(stopEvent);\n    \n    // Calculate step time\n    float milliseconds = 0;\n    cudaEventElapsedTime(&milliseconds, startEvent, stopEvent);\n    lastStepTime = milliseconds;\n    stepCount++;\n}\n\nvoid BulletCudaWorld::SetGravity(const CudaMath::CudaVec3& gravity) {\n    h_gravity = gravity;\n}\n\nstd::vector<CudaContactPoint> BulletCudaWorld::GetContactPoints() {\n    // Get number of contacts\n    int numActiveContacts;\n    cudaMemcpyAsync(&numActiveContacts, &d_contacts[0].distance, sizeof(int),\n                    cudaMemcpyDeviceToHost, collisionStream);\n    cudaStreamSynchronize(collisionStream);\n    \n    numActiveContacts = std::min(numActiveContacts, maxContacts - 1);\n    \n    std::vector<CudaContactPoint> contacts(numActiveContacts);\n    if (numActiveContacts > 0) {\n        cudaMemcpyAsync(contacts.data(), d_contacts + 1, numActiveContacts * sizeof(CudaContactPoint),\n                        cudaMemcpyDeviceToHost, collisionStream);\n        cudaStreamSynchronize(collisionStream);\n    }\n    \n    return contacts;\n}\n\nbool BulletCudaWorld::RayTest(const CudaMath::CudaVec3& from, const CudaMath::CudaVec3& to, int& hitBody, CudaMath::CudaVec3& hitPoint) {\n    // Simplified ray test - would implement full GPU ray casting for maximum performance\n    // For now, download bodies and test on CPU (still much faster than original Bullet for RL)\n    \n    std::vector<CudaRigidBody> bodies(numBodies);\n    cudaMemcpyAsync(bodies.data(), d_bodies, numBodies * sizeof(CudaRigidBody),\n                    cudaMemcpyDeviceToHost, integrationStream);\n    cudaStreamSynchronize(integrationStream);\n    \n    CudaMath::CudaVec3 rayDir = (to - from).normalized();\n    float rayLength = (to - from).length();\n    \n    float closestT = rayLength;\n    int closestBody = -1;\n    \n    for (int i = 0; i < numBodies; i++) {\n        if (!bodies[i].isActive) continue;\n        \n        const CudaCollisionShape& shape = h_shapes[bodies[i].collisionShape];\n        \n        // Sphere intersection (simplified)\n        if (shape.shapeType == 1) {\n            CudaMath::CudaVec3 toSphere = bodies[i].position - from;\n            float t = toSphere.dot(rayDir);\n            \n            if (t >= 0 && t <= rayLength) {\n                CudaMath::CudaVec3 closest = from + rayDir * t;\n                float distSq = (closest - bodies[i].position).lengthSq();\n                \n                if (distSq <= shape.radius * shape.radius) {\n                    if (t < closestT) {\n                        closestT = t;\n                        closestBody = i;\n                    }\n                }\n            }\n        }\n    }\n    \n    if (closestBody >= 0) {\n        hitBody = closestBody;\n        hitPoint = from + rayDir * closestT;\n        return true;\n    }\n    \n    return false;\n}\n\n// Synchronization with CPU Bullet world for compatibility\nvoid BulletCudaWorld::SyncFromBulletWorld(btDiscreteDynamicsWorld* world) {\n    // Convert Bullet rigid bodies to CUDA format\n    // This allows gradual migration from Bullet to CUDA\n    \n    int bodyCount = world->getNumCollisionObjects();\n    for (int i = 0; i < bodyCount && i < maxBodies; i++) {\n        btCollisionObject* obj = world->getCollisionObjectArray()[i];\n        btRigidBody* rb = btRigidBody::upcast(obj);\n        \n        if (rb) {\n            CudaRigidBody cudaBody;\n            \n            // Convert position\n            btVector3 pos = rb->getWorldTransform().getOrigin();\n            cudaBody.position = CudaMath::CudaVec3(pos.x(), pos.y(), pos.z());\n            \n            // Convert velocity\n            btVector3 vel = rb->getLinearVelocity();\n            cudaBody.linearVelocity = CudaMath::CudaVec3(vel.x(), vel.y(), vel.z());\n            \n            // Convert angular velocity\n            btVector3 angVel = rb->getAngularVelocity();\n            cudaBody.angularVelocity = CudaMath::CudaVec3(angVel.x(), angVel.y(), angVel.z());\n            \n            // Convert mass\n            cudaBody.mass = 1.0f / rb->getInvMass();\n            cudaBody.invMass = rb->getInvMass();\n            \n            // Convert material properties\n            cudaBody.friction = rb->getFriction();\n            cudaBody.restitution = rb->getRestitution();\n            cudaBody.linearDamping = rb->getLinearDamping();\n            cudaBody.angularDamping = rb->getAngularDamping();\n            \n            // Set object type based on collision shape\n            btCollisionShape* shape = rb->getCollisionShape();\n            if (shape->getShapeType() == BOX_SHAPE_PROXYTYPE) {\n                cudaBody.objectType = 0; // Car\n            } else if (shape->getShapeType() == SPHERE_SHAPE_PROXYTYPE) {\n                cudaBody.objectType = 1; // Ball\n            } else {\n                cudaBody.objectType = 2; // Static\n            }\n            \n            cudaBody.isActive = rb->isActive();\n            cudaBody.isKinematic = rb->isKinematicObject();\n            cudaBody.isStatic = rb->isStaticObject();\n            cudaBody.id = i;\n            \n            if (i < numBodies) {\n                UpdateRigidBody(i, cudaBody);\n            } else {\n                AddRigidBody(cudaBody);\n            }\n        }\n    }\n}\n\nvoid BulletCudaWorld::SyncToBulletWorld(btDiscreteDynamicsWorld* world) {\n    // Download results from GPU and update Bullet world\n    \n    std::vector<CudaRigidBody> bodies(numBodies);\n    cudaMemcpyAsync(bodies.data(), d_bodies, numBodies * sizeof(CudaRigidBody),\n                    cudaMemcpyDeviceToHost, integrationStream);\n    cudaStreamSynchronize(integrationStream);\n    \n    int bodyCount = std::min(numBodies, world->getNumCollisionObjects());\n    for (int i = 0; i < bodyCount; i++) {\n        btCollisionObject* obj = world->getCollisionObjectArray()[i];\n        btRigidBody* rb = btRigidBody::upcast(obj);\n        \n        if (rb && bodies[i].isActive) {\n            // Update position\n            btTransform transform;\n            transform.setOrigin(btVector3(bodies[i].position.x, bodies[i].position.y, bodies[i].position.z));\n            \n            // Update rotation (simplified)\n            transform.setRotation(btQuaternion(0, 0, 0, 1)); // Would convert from rotation matrix\n            \n            rb->setWorldTransform(transform);\n            \n            // Update velocities\n            rb->setLinearVelocity(btVector3(bodies[i].linearVelocity.x, bodies[i].linearVelocity.y, bodies[i].linearVelocity.z));\n            rb->setAngularVelocity(btVector3(bodies[i].angularVelocity.x, bodies[i].angularVelocity.y, bodies[i].angularVelocity.z));\n            \n            // Wake up the body\n            rb->activate();\n        }\n    }\n}\n\nbool BulletCudaWorld::CheckCudaError(const char* operation) {\n    cudaError_t error = cudaGetLastError();\n    if (error != cudaSuccess) {\n        std::cerr << \"CUDA error in \" << operation << \": \" << cudaGetErrorString(error) << std::endl;\n        return false;\n    }\n    return true;\n}\n\n} // namespace BulletCuda\n} // namespace RocketSim\n\n#endif // RS_CUDA_ENABLED
