#include "CudaPhysicsEngine.cuh"
#include "../../Math/CudaMath.cuh"

#ifdef RS_CUDA_ENABLED

using namespace RocketSim::CudaMath;
using namespace RocketSim::CudaPhysics;

// Car physics constants on GPU
__constant__ float CAR_MAX_SPEED = 2300.0f;
__constant__ float CAR_BRAKE_FORCE = 3500.0f;
__constant__ float CAR_THROTTLE_FORCE = 1600.0f;
__constant__ float CAR_BOOST_FORCE = 991.666f;
__constant__ float CAR_AIR_CONTROL_FORCE = 300.0f;
__constant__ float CAR_JUMP_FORCE = 292.0f;
__constant__ float CAR_FLIP_TORQUE = 260.0f;

// Ball physics constants
__constant__ float BALL_MASS = 30.0f;
__constant__ float BALL_FRICTION = 0.35f;
__constant__ float BALL_RESTITUTION = 0.6f;
__constant__ float BALL_DRAG = 0.0305f;

// High-performance car physics kernel with maximum optimization
__global__ void CarPhysicsKernel(
    CudaCarState* carStates,
    CudaCarControls* carControls,
    float deltaTime,
    int numCars
) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= numCars) return;
    
    CudaCarState& car = carStates[idx];
    const CudaCarControls& controls = carControls[idx];
    
    // Fast local copies for better memory access
    CudaVec3 velocity = car.physState.vel;
    CudaVec3 position = car.physState.pos;
    CudaVec3 angularVel = car.physState.angVel;
    CudaRotMat rotation = car.physState.rotMat;
    
    // Ground contact check (simplified for speed)\n    bool onGround = (position.z < 17.0f && velocity.z > -500.0f);\n    car.isOnGround = onGround;\n    \n    // Boost management\n    if (controls.boost && car.boost > 0 && onGround) {\n        car.boost = fmaxf(0, car.boost - 33.33f * deltaTime);\n        \n        // Apply boost force in forward direction\n        CudaVec3 forward = rotation * CudaVec3(1, 0, 0);\n        velocity = velocity + forward * CAR_BOOST_FORCE * deltaTime;\n    }\n    \n    // Throttle/brake\n    if (onGround) {\n        CudaVec3 forward = rotation * CudaVec3(1, 0, 0);\n        float forwardSpeed = velocity.dot(forward);\n        \n        if (controls.throttle > 0) {\n            if (forwardSpeed < CAR_MAX_SPEED) {\n                velocity = velocity + forward * controls.throttle * CAR_THROTTLE_FORCE * deltaTime;\n            }\n        } else if (controls.throttle < 0) {\n            velocity = velocity + forward * controls.throttle * CAR_BRAKE_FORCE * deltaTime;\n        }\n        \n        // Steering\n        if (fabsf(controls.steer) > 0.01f && forwardSpeed > 50.0f) {\n            float steerInfluence = fminf(1.0f, forwardSpeed / 1000.0f);\n            angularVel.z += controls.steer * steerInfluence * 3.0f;\n        }\n        \n        // Ground friction\n        velocity = velocity * 0.99f;\n        angularVel = angularVel * 0.95f;\n    } else {\n        // Air control\n        CudaVec3 airControl = CudaVec3(controls.pitch, controls.yaw, controls.roll);\n        angularVel = angularVel + airControl * CAR_AIR_CONTROL_FORCE * deltaTime;\n        \n        // Air resistance\n        velocity = velocity * 0.9995f;\n        angularVel = angularVel * 0.98f;\n    }\n    \n    // Jump mechanics\n    if (controls.jump && onGround && !car.hasJumped) {\n        velocity.z += CAR_JUMP_FORCE;\n        car.hasJumped = true;\n        car.jumpTime = 0;\n    }\n    \n    if (car.hasJumped && !onGround) {\n        car.jumpTime += deltaTime;\n        \n        // Double jump/flip\n        if (controls.jump && car.jumpTime > 0.1f && !car.hasDoubleJumped) {\n            if (fabsf(controls.pitch) > 0.5f || fabsf(controls.yaw) > 0.5f || fabsf(controls.roll) > 0.5f) {\n                // Flip\n                car.flipRelTorque = CudaVec3(controls.pitch, controls.yaw, controls.roll) * CAR_FLIP_TORQUE;\n                car.hasFlipped = true;\n                car.flipTime = 0;\n            } else {\n                // Double jump\n                velocity.z += CAR_JUMP_FORCE * 0.8f;\n                car.hasDoubleJumped = true;\n            }\n        }\n    }\n    \n    // Flip execution\n    if (car.hasFlipped && car.flipTime < 0.65f) {\n        car.flipTime += deltaTime;\n        CudaVec3 worldTorque = rotation * car.flipRelTorque;\n        angularVel = angularVel + worldTorque * deltaTime;\n    }\n    \n    // Gravity\n    velocity.z += CUDA_GRAVITY * deltaTime;\n    \n    // Reset jump state when on ground\n    if (onGround && car.hasJumped) {\n        car.hasJumped = false;\n        car.hasDoubleJumped = false;\n        car.hasFlipped = false;\n        car.jumpTime = 0;\n        car.flipTime = 0;\n        car.flipRelTorque = CudaVec3(0, 0, 0);\n    }\n    \n    // Update rotation matrix from angular velocity (simplified)\n    float angSpeed = angularVel.length();\n    if (angSpeed > 0.001f) {\n        // Rodrigues' rotation formula (simplified for speed)\n        float angle = angSpeed * deltaTime;\n        CudaVec3 axis = angularVel * (1.0f / angSpeed);\n        \n        float cosA = fastCos(angle);\n        float sinA = fastSin(angle);\n        float oneMinusCosA = 1.0f - cosA;\n        \n        // Apply rotation to current rotation matrix (simplified)\n        // This is a performance approximation for better GPU utilization\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                rotation.m[i][j] *= cosA;\n            }\n        }\n    }\n    \n    // Update position\n    position = position + velocity * deltaTime;\n    \n    // Write back results\n    car.physState.pos = position;\n    car.physState.vel = velocity;\n    car.physState.angVel = angularVel;\n    car.physState.rotMat = rotation;\n}\n\n// Ultra-fast ball physics kernel\n__global__ void BallPhysicsKernel(\n    CudaBallState* ballState,\n    float deltaTime\n) {\n    if (threadIdx.x != 0 || blockIdx.x != 0) return; // Only one thread for ball\n    \n    CudaVec3 velocity = ballState->physState.vel;\n    CudaVec3 position = ballState->physState.pos;\n    CudaVec3 angularVel = ballState->physState.angVel;\n    \n    // Gravity\n    velocity.z += CUDA_GRAVITY * deltaTime;\n    \n    // Air resistance\n    float speed = velocity.length();\n    if (speed > 0.1f) {\n        CudaVec3 dragForce = velocity * (-BALL_DRAG * speed / BALL_MASS);\n        velocity = velocity + dragForce * deltaTime;\n    }\n    \n    // Angular damping\n    angularVel = angularVel * 0.999f;\n    \n    // Update position\n    position = position + velocity * deltaTime;\n    \n    // Ground bounce (simplified)\n    if (position.z < CUDA_BALL_RADIUS) {\n        position.z = CUDA_BALL_RADIUS;\n        velocity.z = fabsf(velocity.z) * BALL_RESTITUTION;\n        velocity.x *= BALL_FRICTION;\n        velocity.y *= BALL_FRICTION;\n        \n        // Add spin from bounce\n        angularVel.x += velocity.y * 0.1f;\n        angularVel.y -= velocity.x * 0.1f;\n    }\n    \n    // Write back results\n    ballState->physState.pos = position;\n    ballState->physState.vel = velocity;\n    ballState->physState.angVel = angularVel;\n}\n\n// High-performance collision detection kernel\n__global__ void CollisionDetectionKernel(\n    CudaCarState* carStates,\n    CudaBallState* ballState,\n    float* arenaVertices,\n    int* arenaIndices,\n    CudaCollisionInfo* collisions,\n    int numCars,\n    int arenaVertexCount,\n    int arenaIndexCount,\n    int maxCollisions\n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    \n    if (idx >= numCars + 1) return; // +1 for ball\n    \n    int collisionIdx = atomicAdd((int*)&collisions[0].penetration, 1);\n    if (collisionIdx >= maxCollisions) return;\n    \n    if (idx < numCars) {\n        // Car-ball collision\n        CudaVec3 carPos = carStates[idx].physState.pos;\n        CudaVec3 ballPos = ballState->physState.pos;\n        CudaVec3 diff = carPos - ballPos;\n        float distSq = diff.lengthSq();\n        float minDist = CUDA_CAR_HEIGHT + CUDA_BALL_RADIUS;\n        \n        if (distSq < minDist * minDist) {\n            float dist = fastSqrtf(distSq);\n            collisions[collisionIdx].contactPoint = (carPos + ballPos) * 0.5f;\n            collisions[collisionIdx].normal = diff * (1.0f / dist);\n            collisions[collisionIdx].penetration = minDist - dist;\n            collisions[collisionIdx].objectA = idx;\n            collisions[collisionIdx].objectB = -1; // Ball\n            collisions[collisionIdx].type = 0; // Car-ball\n        }\n        \n        // Car-car collisions\n        for (int j = idx + 1; j < numCars; j++) {\n            CudaVec3 otherCarPos = carStates[j].physState.pos;\n            CudaVec3 carDiff = carPos - otherCarPos;\n            float carDistSq = carDiff.lengthSq();\n            float carMinDist = CUDA_CAR_HEIGHT * 2;\n            \n            if (carDistSq < carMinDist * carMinDist) {\n                int newCollisionIdx = atomicAdd((int*)&collisions[0].penetration, 1);\n                if (newCollisionIdx < maxCollisions) {\n                    float carDist = fastSqrtf(carDistSq);\n                    collisions[newCollisionIdx].contactPoint = (carPos + otherCarPos) * 0.5f;\n                    collisions[newCollisionIdx].normal = carDiff * (1.0f / carDist);\n                    collisions[newCollisionIdx].penetration = carMinDist - carDist;\n                    collisions[newCollisionIdx].objectA = idx;\n                    collisions[newCollisionIdx].objectB = j;\n                    collisions[newCollisionIdx].type = 1; // Car-car\n                }\n            }\n        }\n    }\n}\n\n// Optimized collision response kernel\n__global__ void CollisionResponseKernel(\n    CudaCarState* carStates,\n    CudaBallState* ballState,\n    CudaCollisionInfo* collisions,\n    int numCollisions,\n    float deltaTime\n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= numCollisions) return;\n    \n    CudaCollisionInfo& collision = collisions[idx];\n    \n    if (collision.type == 0) { // Car-ball collision\n        CudaCarState& car = carStates[collision.objectA];\n        \n        float impulse = collision.penetration * 1000.0f;\n        CudaVec3 impulseVec = collision.normal * impulse;\n        \n        // Apply impulse to car\n        car.physState.vel = car.physState.vel + impulseVec * deltaTime * 0.5f;\n        \n        // Apply impulse to ball\n        ballState->physState.vel = ballState->physState.vel - impulseVec * deltaTime * 2.0f;\n        \n        // Separate objects\n        car.physState.pos = car.physState.pos + collision.normal * (collision.penetration * 0.5f);\n        ballState->physState.pos = ballState->physState.pos - collision.normal * (collision.penetration * 0.5f);\n        \n    } else if (collision.type == 1) { // Car-car collision\n        CudaCarState& carA = carStates[collision.objectA];\n        CudaCarState& carB = carStates[collision.objectB];\n        \n        float impulse = collision.penetration * 500.0f;\n        CudaVec3 impulseVec = collision.normal * impulse;\n        \n        // Apply impulses\n        carA.physState.vel = carA.physState.vel + impulseVec * deltaTime;\n        carB.physState.vel = carB.physState.vel - impulseVec * deltaTime;\n        \n        // Separate cars\n        carA.physState.pos = carA.physState.pos + collision.normal * (collision.penetration * 0.5f);\n        carB.physState.pos = carB.physState.pos - collision.normal * (collision.penetration * 0.5f);\n    }\n}\n\n// Batch update kernel for maximum parallelism\n__global__ void BatchCarUpdateKernel(\n    CudaCarState* carStates,\n    CudaCarControls* carControls,\n    CudaCollisionInfo* collisions,\n    float deltaTime,\n    int numCars,\n    int numCollisions\n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= numCars) return;\n    \n    // This kernel combines multiple update steps for better GPU utilization\n    CudaCarState& car = carStates[idx];\n    \n    // Velocity limiting\n    float speed = car.physState.vel.length();\n    if (speed > CAR_MAX_SPEED * 1.2f) {\n        car.physState.vel = car.physState.vel * (CAR_MAX_SPEED * 1.2f / speed);\n    }\n    \n    // Angular velocity limiting\n    float angSpeed = car.physState.angVel.length();\n    if (angSpeed > 6.0f) {\n        car.physState.angVel = car.physState.angVel * (6.0f / angSpeed);\n    }\n    \n    // Update boost regeneration on pads (simplified)\n    if (car.isOnGround && car.boost < 100.0f) {\n        // Check if near boost pad (simplified spatial check)\n        CudaVec3 pos = car.physState.pos;\n        float x = pos.x;\n        float y = pos.y;\n        \n        // Hardcoded boost pad positions for performance\n        bool nearBoostPad = false;\n        if ((fabsf(x) > 3000 && fabsf(y) < 100) || // Corner boosts\n            (fabsf(x) < 100 && fabsf(y) > 2500)) {   // Side boosts\n            nearBoostPad = true;\n        }\n        \n        if (nearBoostPad) {\n            car.boost = fminf(100.0f, car.boost + 60.0f * deltaTime);\n        }\n    }\n}\n\n// C wrapper functions for CUDA kernels\nextern \"C\" {\n    void LaunchCarPhysicsKernel(\n        CudaCarState* carStates,\n        CudaCarControls* carControls,\n        float deltaTime,\n        int numCars,\n        cudaStream_t stream\n    ) {\n        dim3 blockSize(256);\n        dim3 gridSize((numCars + blockSize.x - 1) / blockSize.x);\n        \n        CarPhysicsKernel<<<gridSize, blockSize, 0, stream>>>(\n            carStates, carControls, deltaTime, numCars\n        );\n    }\n    \n    void LaunchBallPhysicsKernel(\n        CudaBallState* ballState,\n        float deltaTime,\n        cudaStream_t stream\n    ) {\n        BallPhysicsKernel<<<1, 1, 0, stream>>>(ballState, deltaTime);\n    }\n    \n    void LaunchCollisionDetectionKernel(\n        CudaCarState* carStates,\n        CudaBallState* ballState,\n        float* arenaVertices,\n        int* arenaIndices,\n        CudaCollisionInfo* collisions,\n        int numCars,\n        int arenaVertexCount,\n        int arenaIndexCount,\n        int maxCollisions,\n        cudaStream_t stream\n    ) {\n        dim3 blockSize(256);\n        dim3 gridSize((numCars + 1 + blockSize.x - 1) / blockSize.x);\n        \n        // Reset collision counter\n        cudaMemsetAsync(&collisions[0].penetration, 0, sizeof(int), stream);\n        \n        CollisionDetectionKernel<<<gridSize, blockSize, 0, stream>>>(\n            carStates, ballState, arenaVertices, arenaIndices, collisions,\n            numCars, arenaVertexCount, arenaIndexCount, maxCollisions\n        );\n    }\n    \n    void LaunchCollisionResponseKernel(\n        CudaCarState* carStates,\n        CudaBallState* ballState,\n        CudaCollisionInfo* collisions,\n        int numCollisions,\n        float deltaTime,\n        cudaStream_t stream\n    ) {\n        dim3 blockSize(256);\n        dim3 gridSize((numCollisions + blockSize.x - 1) / blockSize.x);\n        \n        CollisionResponseKernel<<<gridSize, blockSize, 0, stream>>>(\n            carStates, ballState, collisions, numCollisions, deltaTime\n        );\n    }\n    \n    void LaunchBatchCarUpdateKernel(\n        CudaCarState* carStates,\n        CudaCarControls* carControls,\n        CudaCollisionInfo* collisions,\n        float deltaTime,\n        int numCars,\n        int numCollisions,\n        cudaStream_t stream\n    ) {\n        dim3 blockSize(256);\n        dim3 gridSize((numCars + blockSize.x - 1) / blockSize.x);\n        \n        BatchCarUpdateKernel<<<gridSize, blockSize, 0, stream>>>(\n            carStates, carControls, collisions, deltaTime, numCars, numCollisions\n        );\n    }\n}\n\n#endif // RS_CUDA_ENABLED
