#include "CudaPhysicsEngine.cuh"\n#include <iostream>\n#include <chrono>\n\n#ifdef RS_CUDA_ENABLED\n\nnamespace RocketSim {\nnamespace CudaPhysics {\n\nCudaPhysicsEngine::CudaPhysicsEngine(int maxCars, int maxCollisions) \n    : maxCars(maxCars), maxCollisions(maxCollisions), tickTime(1.0f/120.0f),\n      d_carStates(nullptr), d_ballState(nullptr), d_carControls(nullptr),\n      d_collisions(nullptr), d_arenaVertices(nullptr), d_arenaIndices(nullptr),\n      arenaVertexCount(0), arenaIndexCount(0),\n      lastStepTime(0.0f), totalSteps(0) {\n    \n    // Initialize host memory\n    h_carStates.resize(maxCars);\n    h_carControls.resize(maxCars);\n    h_collisions.resize(maxCollisions);\n}\n\nCudaPhysicsEngine::~CudaPhysicsEngine() {\n    Cleanup();\n}\n\nbool CudaPhysicsEngine::Initialize() {\n    // Create CUDA streams for parallel execution\n    if (cudaStreamCreate(&physicsStream) != cudaSuccess) {\n        std::cerr << \"Failed to create physics stream\" << std::endl;\n        return false;\n    }\n    \n    if (cudaStreamCreate(&collisionStream) != cudaSuccess) {\n        std::cerr << \"Failed to create collision stream\" << std::endl;\n        return false;\n    }\n    \n    if (cudaStreamCreate(&memoryStream) != cudaSuccess) {\n        std::cerr << \"Failed to create memory stream\" << std::endl;\n        return false;\n    }\n    \n    // Allocate device memory\n    if (cudaMalloc(&d_carStates, maxCars * sizeof(CudaCarState)) != cudaSuccess) {\n        std::cerr << \"Failed to allocate car states memory\" << std::endl;\n        return false;\n    }\n    \n    if (cudaMalloc(&d_ballState, sizeof(CudaBallState)) != cudaSuccess) {\n        std::cerr << \"Failed to allocate ball state memory\" << std::endl;\n        return false;\n    }\n    \n    if (cudaMalloc(&d_carControls, maxCars * sizeof(CudaCarControls)) != cudaSuccess) {\n        std::cerr << \"Failed to allocate car controls memory\" << std::endl;\n        return false;\n    }\n    \n    if (cudaMalloc(&d_collisions, maxCollisions * sizeof(CudaCollisionInfo)) != cudaSuccess) {\n        std::cerr << \"Failed to allocate collisions memory\" << std::endl;\n        return false;\n    }\n    \n    // Create CUDA events for timing\n    if (cudaEventCreate(&startEvent) != cudaSuccess ||\n        cudaEventCreate(&stopEvent) != cudaSuccess) {\n        std::cerr << \"Failed to create CUDA events\" << std::endl;\n        return false;\n    }\n    \n    // Initialize memory to zero\n    cudaMemset(d_carStates, 0, maxCars * sizeof(CudaCarState));\n    cudaMemset(d_ballState, 0, sizeof(CudaBallState));\n    cudaMemset(d_carControls, 0, maxCars * sizeof(CudaCarControls));\n    cudaMemset(d_collisions, 0, maxCollisions * sizeof(CudaCollisionInfo));\n    \n    return CheckCudaError(\"Initialize\");\n}\n\nvoid CudaPhysicsEngine::Cleanup() {\n    // Free device memory\n    if (d_carStates) { cudaFree(d_carStates); d_carStates = nullptr; }\n    if (d_ballState) { cudaFree(d_ballState); d_ballState = nullptr; }\n    if (d_carControls) { cudaFree(d_carControls); d_carControls = nullptr; }\n    if (d_collisions) { cudaFree(d_collisions); d_collisions = nullptr; }\n    if (d_arenaVertices) { cudaFree(d_arenaVertices); d_arenaVertices = nullptr; }\n    if (d_arenaIndices) { cudaFree(d_arenaIndices); d_arenaIndices = nullptr; }\n    \n    // Destroy streams\n    if (physicsStream) { cudaStreamDestroy(physicsStream); }\n    if (collisionStream) { cudaStreamDestroy(collisionStream); }\n    if (memoryStream) { cudaStreamDestroy(memoryStream); }\n    \n    // Destroy events\n    if (startEvent) { cudaEventDestroy(startEvent); }\n    if (stopEvent) { cudaEventDestroy(stopEvent); }\n}\n\nvoid CudaPhysicsEngine::UploadCarStates(const std::vector<Car*>& cars) {\n    int numCars = std::min((int)cars.size(), maxCars);\n    \n    // Convert Car objects to CudaCarState\n    for (int i = 0; i < numCars; i++) {\n        const Car* car = cars[i];\n        CudaCarState& cudaCar = h_carStates[i];\n        \n        // Copy physics state\n        cudaCar.physState.pos = CudaMath::CudaVec3(car->GetState().pos);\n        cudaCar.physState.vel = CudaMath::CudaVec3(car->GetState().vel);\n        cudaCar.physState.angVel = CudaMath::CudaVec3(car->GetState().angVel);\n        cudaCar.physState.rotMat = CudaMath::CudaRotMat(car->GetState().rotMat);\n        \n        // Copy car-specific state\n        cudaCar.boost = car->GetState().boost;\n        cudaCar.isOnGround = car->GetState().isOnGround;\n        cudaCar.hasJumped = car->GetState().hasJumped;\n        cudaCar.hasDoubleJumped = car->GetState().hasDoubleJumped;\n        cudaCar.hasFlipped = car->GetState().hasFlipped;\n        cudaCar.jumpTime = car->GetState().jumpTime;\n        cudaCar.flipTime = car->GetState().flipTime;\n        cudaCar.flipRelTorque = CudaMath::CudaVec3(car->GetState().flipRelTorque);\n        \n        for (int j = 0; j < 4; j++) {\n            cudaCar.wheelContactTime[j] = car->GetState().wheelsWithContact[j] ? 1.0f : 0.0f;\n        }\n        \n        cudaCar.team = (int)car->team;\n        cudaCar.id = car->id;\n    }\n    \n    // Upload to GPU\n    cudaMemcpyAsync(d_carStates, h_carStates.data(), numCars * sizeof(CudaCarState),\n                    cudaMemcpyHostToDevice, memoryStream);\n}\n\nvoid CudaPhysicsEngine::UploadBallState(const Ball* ball) {\n    // Convert Ball to CudaBallState\n    h_ballState.physState.pos = CudaMath::CudaVec3(ball->GetState().pos);\n    h_ballState.physState.vel = CudaMath::CudaVec3(ball->GetState().vel);\n    h_ballState.physState.angVel = CudaMath::CudaVec3(ball->GetState().angVel);\n    h_ballState.physState.rotMat = CudaMath::CudaRotMat(ball->GetState().rotMat);\n    \n    h_ballState.radius = 92.75f; // Standard ball radius\n    h_ballState.mass = 30.0f;    // Standard ball mass\n    h_ballState.chargeLevel = ball->GetState().dsInfo.chargeLevel;\n    h_ballState.accumulatedHitForce = ball->GetState().dsInfo.accumulatedHitForce;\n    h_ballState.hasDamaged = ball->GetState().dsInfo.hasDamaged;\n    \n    // Upload to GPU\n    cudaMemcpyAsync(d_ballState, &h_ballState, sizeof(CudaBallState),\n                    cudaMemcpyHostToDevice, memoryStream);\n}\n\nvoid CudaPhysicsEngine::UploadCarControls(const std::vector<CarControls>& controls) {\n    int numControls = std::min((int)controls.size(), maxCars);\n    \n    // Convert CarControls to CudaCarControls\n    for (int i = 0; i < numControls; i++) {\n        const CarControls& ctrl = controls[i];\n        CudaCarControls& cudaCtrl = h_carControls[i];\n        \n        cudaCtrl.throttle = ctrl.throttle;\n        cudaCtrl.steer = ctrl.steer;\n        cudaCtrl.pitch = ctrl.pitch;\n        cudaCtrl.yaw = ctrl.yaw;\n        cudaCtrl.roll = ctrl.roll;\n        cudaCtrl.jump = ctrl.jump;\n        cudaCtrl.boost = ctrl.boost;\n        cudaCtrl.handbrake = ctrl.handbrake;\n    }\n    \n    // Upload to GPU\n    cudaMemcpyAsync(d_carControls, h_carControls.data(), numControls * sizeof(CudaCarControls),\n                    cudaMemcpyHostToDevice, memoryStream);\n}\n\nvoid CudaPhysicsEngine::UploadArenaGeometry(const std::vector<float>& vertices, const std::vector<int>& indices) {\n    arenaVertexCount = vertices.size() / 3;\n    arenaIndexCount = indices.size();\n    \n    // Allocate GPU memory for arena geometry\n    if (d_arenaVertices) cudaFree(d_arenaVertices);\n    if (d_arenaIndices) cudaFree(d_arenaIndices);\n    \n    cudaMalloc(&d_arenaVertices, vertices.size() * sizeof(float));\n    cudaMalloc(&d_arenaIndices, indices.size() * sizeof(int));\n    \n    // Upload geometry data\n    cudaMemcpyAsync(d_arenaVertices, vertices.data(), vertices.size() * sizeof(float),\n                    cudaMemcpyHostToDevice, memoryStream);\n    cudaMemcpyAsync(d_arenaIndices, indices.data(), indices.size() * sizeof(int),\n                    cudaMemcpyHostToDevice, memoryStream);\n}\n\nvoid CudaPhysicsEngine::DownloadCarStates(std::vector<Car*>& cars) {\n    int numCars = std::min((int)cars.size(), maxCars);\n    \n    // Download from GPU\n    cudaMemcpyAsync(h_carStates.data(), d_carStates, numCars * sizeof(CudaCarState),\n                    cudaMemcpyDeviceToHost, memoryStream);\n    cudaStreamSynchronize(memoryStream);\n    \n    // Convert back to Car objects\n    for (int i = 0; i < numCars; i++) {\n        Car* car = cars[i];\n        const CudaCarState& cudaCar = h_carStates[i];\n        \n        CarState carState = car->GetState();\n        \n        // Copy physics state back\n        carState.pos = Vec(cudaCar.physState.pos.x, cudaCar.physState.pos.y, cudaCar.physState.pos.z);\n        carState.vel = Vec(cudaCar.physState.vel.x, cudaCar.physState.vel.y, cudaCar.physState.vel.z);\n        carState.angVel = Vec(cudaCar.physState.angVel.x, cudaCar.physState.angVel.y, cudaCar.physState.angVel.z);\n        \n        // Copy car-specific state back\n        carState.boost = cudaCar.boost;\n        carState.isOnGround = cudaCar.isOnGround;\n        carState.hasJumped = cudaCar.hasJumped;\n        carState.hasDoubleJumped = cudaCar.hasDoubleJumped;\n        carState.hasFlipped = cudaCar.hasFlipped;\n        carState.jumpTime = cudaCar.jumpTime;\n        carState.flipTime = cudaCar.flipTime;\n        carState.flipRelTorque = Vec(cudaCar.flipRelTorque.x, cudaCar.flipRelTorque.y, cudaCar.flipRelTorque.z);\n        \n        for (int j = 0; j < 4; j++) {\n            carState.wheelsWithContact[j] = cudaCar.wheelContactTime[j] > 0.5f;\n        }\n        \n        car->SetState(carState);\n    }\n}\n\nvoid CudaPhysicsEngine::DownloadBallState(Ball* ball) {\n    // Download from GPU\n    cudaMemcpyAsync(&h_ballState, d_ballState, sizeof(CudaBallState),\n                    cudaMemcpyDeviceToHost, memoryStream);\n    cudaStreamSynchronize(memoryStream);\n    \n    // Convert back to Ball object\n    BallState ballState = ball->GetState();\n    \n    ballState.pos = Vec(h_ballState.physState.pos.x, h_ballState.physState.pos.y, h_ballState.physState.pos.z);\n    ballState.vel = Vec(h_ballState.physState.vel.x, h_ballState.physState.vel.y, h_ballState.physState.vel.z);\n    ballState.angVel = Vec(h_ballState.physState.angVel.x, h_ballState.physState.angVel.y, h_ballState.physState.angVel.z);\n    \n    ballState.dsInfo.chargeLevel = h_ballState.chargeLevel;\n    ballState.dsInfo.accumulatedHitForce = h_ballState.accumulatedHitForce;\n    ballState.dsInfo.hasDamaged = h_ballState.hasDamaged;\n    \n    ball->SetState(ballState);\n}\n\nvoid CudaPhysicsEngine::DownloadCollisions(std::vector<CudaCollisionInfo>& collisions) {\n    // Download collision count first\n    int numCollisions;\n    cudaMemcpyAsync(&numCollisions, &d_collisions[0].penetration, sizeof(int),\n                    cudaMemcpyDeviceToHost, memoryStream);\n    cudaStreamSynchronize(memoryStream);\n    \n    numCollisions = std::min(numCollisions, maxCollisions - 1);\n    \n    if (numCollisions > 0) {\n        cudaMemcpyAsync(h_collisions.data(), d_collisions + 1, numCollisions * sizeof(CudaCollisionInfo),\n                        cudaMemcpyDeviceToHost, memoryStream);\n        cudaStreamSynchronize(memoryStream);\n        \n        collisions.resize(numCollisions);\n        std::copy(h_collisions.begin(), h_collisions.begin() + numCollisions, collisions.begin());\n    } else {\n        collisions.clear();\n    }\n}\n\nvoid CudaPhysicsEngine::SimulatePhysicsStep(float deltaTime, int numCars) {\n    // Start timing\n    cudaEventRecord(startEvent, 0);\n    \n    // Launch kernels in parallel streams\n    \n    // 1. Update car physics\n    LaunchCarPhysicsKernel(d_carStates, d_carControls, deltaTime, numCars, physicsStream);\n    \n    // 2. Update ball physics (can run in parallel)\n    LaunchBallPhysicsKernel(d_ballState, deltaTime, physicsStream);\n    \n    // 3. Detect collisions\n    LaunchCollisionDetectionKernel(\n        d_carStates, d_ballState, d_arenaVertices, d_arenaIndices, d_collisions,\n        numCars, arenaVertexCount, arenaIndexCount, maxCollisions, collisionStream\n    );\n    \n    // Synchronize before collision response\n    cudaStreamSynchronize(physicsStream);\n    cudaStreamSynchronize(collisionStream);\n    \n    // 4. Get collision count\n    int numCollisions;\n    cudaMemcpyAsync(&numCollisions, &d_collisions[0].penetration, sizeof(int),\n                    cudaMemcpyDeviceToHost, memoryStream);\n    cudaStreamSynchronize(memoryStream);\n    numCollisions = std::min(numCollisions, maxCollisions - 1);\n    \n    // 5. Resolve collisions\n    if (numCollisions > 0) {\n        LaunchCollisionResponseKernel(\n            d_carStates, d_ballState, d_collisions + 1, numCollisions, deltaTime, collisionStream\n        );\n    }\n    \n    // 6. Final batch update\n    LaunchBatchCarUpdateKernel(\n        d_carStates, d_carControls, d_collisions + 1, deltaTime, numCars, numCollisions, physicsStream\n    );\n    \n    // Synchronize all streams\n    cudaStreamSynchronize(physicsStream);\n    cudaStreamSynchronize(collisionStream);\n    \n    // End timing\n    cudaEventRecord(stopEvent, 0);\n    cudaEventSynchronize(stopEvent);\n    \n    float milliseconds = 0;\n    cudaEventElapsedTime(&milliseconds, startEvent, stopEvent);\n    lastStepTime = milliseconds;\n    totalSteps++;\n}\n\nvoid CudaPhysicsEngine::BeginPhysicsStep(float deltaTime, int numCars) {\n    // Async version for maximum performance\n    cudaEventRecord(startEvent, 0);\n    \n    LaunchCarPhysicsKernel(d_carStates, d_carControls, deltaTime, numCars, physicsStream);\n    LaunchBallPhysicsKernel(d_ballState, deltaTime, physicsStream);\n    LaunchCollisionDetectionKernel(\n        d_carStates, d_ballState, d_arenaVertices, d_arenaIndices, d_collisions,\n        numCars, arenaVertexCount, arenaIndexCount, maxCollisions, collisionStream\n    );\n}\n\nvoid CudaPhysicsEngine::EndPhysicsStep() {\n    cudaStreamSynchronize(physicsStream);\n    cudaStreamSynchronize(collisionStream);\n    \n    cudaEventRecord(stopEvent, 0);\n    cudaEventSynchronize(stopEvent);\n    \n    float milliseconds = 0;\n    cudaEventElapsedTime(&milliseconds, startEvent, stopEvent);\n    lastStepTime = milliseconds;\n    totalSteps++;\n}\n\nbool CudaPhysicsEngine::CheckCudaError(const char* operation) {\n    cudaError_t error = cudaGetLastError();\n    if (error != cudaSuccess) {\n        std::cerr << \"CUDA error in \" << operation << \": \" << cudaGetErrorString(error) << std::endl;\n        return false;\n    }\n    return true;\n}\n\n} // namespace CudaPhysics\n} // namespace RocketSim\n\n#endif // RS_CUDA_ENABLED
